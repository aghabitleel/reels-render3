name: Render Reel
on:
  repository_dispatch:
    types: [render_reel]

jobs:
  render:
    runs-on: ubuntu-latest
    steps:
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq python3

      - name: Capture payload safely
        shell: bash
        run: |
          set -euo pipefail
          cat > payload.json <<'JSON'
          ${{ toJson(github.event.client_payload) }}
          JSON
          echo "Captured payload:"
          cat payload.json

      - name: Render video
        shell: bash
        run: |
          set -euo pipefail
          PAYLOAD_PATH="payload.json"
          WIDTH=1080
          HEIGHT=1920
          FPS=30
          CHUNK_SEC=4
          OUT_NAME="reel.mp4"

          AUDIO_URL=$(jq -r '.audio_url // ""' "$PAYLOAD_PATH")
          LAYOUT_TYPE=$(jq -r '.layout_config.type // ""' "$PAYLOAD_PATH")
          TH_URL=$(jq -r '.layout_config.talking_head_url // ""' "$PAYLOAD_PATH")
          TH_SPEED=$(jq -r '.layout_config.talking_head_speed // 1.0' "$PAYLOAD_PATH")

          BROLL_JSON=$(jq -c 'if (.layout_config.broll_videos | type) == "array" then .layout_config.broll_videos else (.video_urls // []) end' "$PAYLOAD_PATH")
          BROLL_COUNT=$(echo "$BROLL_JSON" | jq 'length')

          if [ -z "$AUDIO_URL" ] || [ "$AUDIO_URL" = "null" ]; then
            echo "Error: audio_url missing"
            exit 1
          fi
          if [ "$LAYOUT_TYPE" != "talking_head_then_broll" ]; then
            echo "Error: layout_config.type must be talking_head_then_broll for this workflow"
            echo "Got: $LAYOUT_TYPE"
            exit 1
          fi
          if [ -z "$TH_URL" ] || [ "$TH_URL" = "null" ]; then
            echo "Error: layout_config.talking_head_url missing"
            exit 1
          fi
          if [ "$BROLL_COUNT" -lt 1 ]; then
            echo "Error: Need at least 1 broll video url"
            exit 1
          fi

          mkdir -p work out

          echo "Downloading audio..."
          curl -L --retry 5 --retry-delay 2 -o work/audio.wav "$AUDIO_URL"

          echo "Downloading talking head..."
          curl -L --retry 5 --retry-delay 2 -o work/talking_head.mp4 "$TH_URL"

          echo "Downloading broll urls..."
          echo "$BROLL_JSON" | jq -r '.[]' > work/broll_urls.txt

          i=0
          while IFS= read -r url; do
            i=$((i+1))
            echo "Downloading broll $i: $url"
            curl -L --retry 5 --retry-delay 2 -o "work/broll_${i}.mp4" "$url" || true
            if [ ! -s "work/broll_${i}.mp4" ]; then
              rm -f "work/broll_${i}.mp4"
            fi
          done < work/broll_urls.txt

          BROLL_FILES_COUNT=$(ls -1 work/broll_*.mp4 2>/dev/null | wc -l | tr -d ' ')
          if [ "$BROLL_FILES_COUNT" -lt 1 ]; then
            echo "Error: could not download any broll clips"
            exit 1
          fi

          AUDIO_DUR=$(ffprobe -v error -show_entries format=duration -of default=nw=1:nk=1 work/audio.wav || echo "0")
          AUDIO_DUR_INT=$(python3 -c "import math; s=float('${AUDIO_DUR}' or '0'); print(max(1, int(math.floor(s + 1e-6))))")
          echo "Audio duration: ${AUDIO_DUR}s (int=${AUDIO_DUR_INT}s)"

          echo "Normalizing talking head..."
          ffmpeg -y -i work/talking_head.mp4 \
            -vf "scale=${WIDTH}:${HEIGHT}:force_original_aspect_ratio=increase,crop=${WIDTH}:${HEIGHT},setsar=1,fps=${FPS},setpts=PTS/${TH_SPEED}" \
            -an -c:v libx264 -preset veryfast -crf 21 work/th_norm.mp4

          TH_DUR_RAW=$(ffprobe -v error -show_entries format=duration -of default=nw=1:nk=1 work/th_norm.mp4 || echo "0")
          TH_DUR_INT=$(python3 -c "import math; s=float('${TH_DUR_RAW}' or '0'); print(max(1, int(math.floor(s + 1e-6))))")

          if [ "$TH_DUR_INT" -gt "$AUDIO_DUR_INT" ]; then
            TH_DUR_INT=$AUDIO_DUR_INT
          fi

          REMAIN=$((AUDIO_DUR_INT - TH_DUR_INT))
          if [ "$REMAIN" -lt 0 ]; then
            REMAIN=0
          fi

          echo "Talking head segment: ${TH_DUR_INT}s"
          echo "Broll segment target: ${REMAIN}s"

          ffmpeg -y -i work/th_norm.mp4 -t "$TH_DUR_INT" -an -c:v libx264 -preset veryfast -crf 21 work/seg_th.mp4

          if [ "$REMAIN" -gt 0 ]; then
            echo "Preparing broll chunks..."
            rm -f work/concat_broll.txt
            : > work/concat_broll.txt

            CHUNKS=$(( (REMAIN + CHUNK_SEC - 1) / CHUNK_SEC ))
            if [ "$CHUNKS" -lt 1 ]; then
              CHUNKS=1
            fi

            mapfile -t BFILES < <(ls -1 work/broll_*.mp4 | sort)
            BCOUNT=${#BFILES[@]}
            if [ "$BCOUNT" -lt 1 ]; then
              echo "Error: no broll files to chunk"
              exit 1
            fi

            for n in $(seq 1 "$CHUNKS"); do
              idx=$(( (n - 1) % BCOUNT ))
              src="${BFILES[$idx]}"

              ffmpeg -y -i "$src" \
                -t "$CHUNK_SEC" \
                -vf "scale=${WIDTH}:${HEIGHT}:force_original_aspect_ratio=increase,crop=${WIDTH}:${HEIGHT},setsar=1,fps=${FPS}" \
                -an -c:v libx264 -preset veryfast -crf 21 "work/bchunk_${n}.mp4"

              echo "file bchunk_${n}.mp4" >> work/concat_broll.txt
            done

            echo "Concatenating broll..."
            cd work
            ffmpeg -y -f concat -safe 0 -i concat_broll.txt -c copy broll_seq_raw.mp4
            cd ..

            ffmpeg -y -i work/broll_seq_raw.mp4 -t "$REMAIN" -an -c:v libx264 -preset veryfast -crf 21 work/seg_broll.mp4

            echo "Concatenating talking head + broll..."
            cat > work/concat_all.txt <<'CONCAT_EOF'
          file seg_th.mp4
          file seg_broll.mp4
          CONCAT_EOF

            cd work
            ffmpeg -y -f concat -safe 0 -i concat_all.txt -c copy stack.mp4
            cd ..
          else
            cp work/seg_th.mp4 work/stack.mp4
          fi

          echo "Generating captions..."
          cat > generate_captions.py <<'PYEOF'
          import json, math

          payload = json.load(open("payload.json","r",encoding="utf-8"))
          lines = payload.get("script_lines") or []
          audio_dur = payload.get("audioDurationSec") or payload.get("audio_duration")
          try:
            audio_dur = float(audio_dur) if audio_dur is not None else None
          except Exception:
            audio_dur = None

          if not audio_dur or audio_dur < 1:
            audio_dur = 1.0

          lines = [str(x).strip() for x in lines if str(x).strip()]
          if not lines:
            lines = [""]

          def ass_time(t):
            h = int(t // 3600)
            t -= h*3600
            m = int(t // 60)
            t -= m*60
            s = int(t)
            cs = int(round((t - s) * 100))
            return f"{h}:{m:02d}:{s:02d}.{cs:02d}"

          W = int(payload.get("width") or 1080)
          H = int(payload.get("height") or 1920)

          x = W // 2
          y = int(H * 0.67)

          n = len(lines)
          slot = audio_dur / n

          ass = []
          ass.append("[Script Info]")
          ass.append("ScriptType: v4.00+")
          ass.append(f"PlayResX: {W}")
          ass.append(f"PlayResY: {H}")
          ass.append("")
          ass.append("[V4+ Styles]")
          ass.append("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding")
          ass.append("Style: Default,Arial,44,&H00FFFFFF,&H000000FF,&H00111111,&H80000000,0,0,0,0,100,100,0,0,3,3,0,2,70,70,50,1")
          ass.append("")
          ass.append("[Events]")
          ass.append("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text")

          for i, text in enumerate(lines):
            start = i * slot
            end = min(audio_dur, (i+1) * slot)
            if end <= start:
              end = start + 0.4
            text = text.replace("\\","\\\\").replace("{","\\{").replace("}","\\}")
            override = f"{{\\an2\\pos({x},{y})\\fad(80,80)}}"
            ass.append(f"Dialogue: 0,{ass_time(start)},{ass_time(end)},Default,,0,0,0,,{override}{text}")

          open("work/captions.ass","w",encoding="utf-8").write("\n".join(ass))
          print("Wrote work/captions.ass with", len(lines), "lines")
          PYEOF

          python3 generate_captions.py

          echo "Burning captions and muxing audio..."
          ffmpeg -y -i work/stack.mp4 -i work/audio.wav \
            -vf "ass=work/captions.ass" \
            -c:v libx264 -preset veryfast -crf 21 \
            -c:a aac -b:a 128k -shortest "out/${OUT_NAME}"

          echo "Done. Output:"
          ls -lh out

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: reel
          path: out/*.mp4
          if-no-files-found: error
