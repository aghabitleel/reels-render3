name: Render Reel

on:
  repository_dispatch:
    types: [render_reel]

permissions:
  contents: write

jobs:
  render:
    runs-on: ubuntu-latest
    env:
      LC_ALL: C

    steps:
      - name: Set up FFmpeg
        uses: FedericoCarboni/setup-ffmpeg@v2
        with:
          version: latest

      - name: Install jq and curl
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Capture payload safely
        shell: bash
        run: |
          set -euo pipefail
          cat > payload.json <<'JSON'
          ${{ toJson(github.event.client_payload) }}
          JSON
          echo "Captured payload:"
          cat payload.json

      - name: Read and validate params
        id: params
        shell: bash
        run: |
          set -euo pipefail

          RAW_AUDIO_URL=$(jq -r 'try .audio_url // ""' payload.json)
          OUT_NAME=$(jq -r 'try .out_name // "reel.mp4"' payload.json)
          WIDTH=$(jq -r 'try .width // 1080' payload.json)
          HEIGHT=$(jq -r 'try .height // 1920' payload.json)
          FPS=$(jq -r 'try .fps // 30' payload.json)
          CHUNK_SEC=$(jq -r 'try .chunk_sec // 4' payload.json)
          MAX_CLIPS=$(jq -r 'try .max_clips // 100' payload.json)
          LAYOUT_TYPE=$(jq -r 'try .layout_config.type // "talking_head_then_broll"' payload.json)
          TH_SPEED=$(jq -r 'try .layout_config.talking_head_speed // 1.0' payload.json)

          if [ "$RAW_AUDIO_URL" = "null" ]; then RAW_AUDIO_URL=""; fi
          if [ "$TH_SPEED" = "null" ] || [ -z "$TH_SPEED" ]; then TH_SPEED=1.0; fi

          if [ -z "$RAW_AUDIO_URL" ] || ! echo "$RAW_AUDIO_URL" | grep -Eiq '^https?://'; then
            echo "Error: client_payload.audio_url is missing or invalid"
            cat payload.json
            exit 1
          fi

          jq -r '
            if (.script_lines | type == "array") then
              .script_lines | map(tostring) | join("\n")
            elif (.script_text | type == "string") then
              .script_text
            else
              ""
            end
          ' payload.json > script.txt

          echo "AUDIO_URL=$RAW_AUDIO_URL" >> $GITHUB_ENV
          echo "OUT_NAME=$OUT_NAME" >> $GITHUB_ENV
          echo "WIDTH=$WIDTH" >> $GITHUB_ENV
          echo "HEIGHT=$HEIGHT" >> $GITHUB_ENV
          echo "FPS=$FPS" >> $GITHUB_ENV
          echo "CHUNK_SEC=$CHUNK_SEC" >> $GITHUB_ENV
          echo "MAX_CLIPS=$MAX_CLIPS" >> $GITHUB_ENV
          echo "LAYOUT_TYPE=$LAYOUT_TYPE" >> $GITHUB_ENV
          echo "TH_SPEED=$TH_SPEED" >> $GITHUB_ENV

          echo "Params: $OUT_NAME ${WIDTH}x${HEIGHT} ${FPS}fps chunk=${CHUNK_SEC}s layout=$LAYOUT_TYPE speed=$TH_SPEED"

      - name: Validate video URLs list
        shell: bash
        run: |
          set -euo pipefail
          if [ "$LAYOUT_TYPE" = "talking_head_then_broll" ]; then
            TH_URL=$(jq -r 'try .layout_config.talking_head_url // ""' payload.json)
            BROLL_COUNT=$(jq -r 'try (.layout_config.broll_videos | length) // 0' payload.json)
            if [ -z "$TH_URL" ] || [ "$BROLL_COUNT" -lt 1 ]; then
              echo "Error: talking_head_then_broll requires talking_head_url and broll_videos"
              cat payload.json
              exit 1
            fi
            echo "Layout: talking head + $BROLL_COUNT broll videos"
          else
            COUNT=$(jq -r 'try (.video_urls | length) // 0' payload.json)
            if [ "$COUNT" -lt 1 ]; then
              echo "Error: client_payload.video_urls is empty"
              cat payload.json
              exit 1
            fi
            echo "Video URL count in payload: $COUNT"
          fi

      - name: Download audio
        shell: bash
        run: |
          set -euo pipefail
          UA="Mozilla/5.0 (X11; Linux x86_64; GH-Actions)"
          echo "Audio URL starts with: ${AUDIO_URL:0:70}..."
          curl -L --fail --retry 5 --retry-delay 2 -A "$UA" "$AUDIO_URL" -o audio.bin
          ffmpeg -y -i audio.bin -c:a aac -b:a 192k -movflags +faststart audio.m4a

      - name: Get audio duration (float)
        id: dur
        shell: bash
        run: |
          set -euo pipefail
          DUR=$(ffprobe -v error -select_streams a:0 -show_entries stream=duration -of default=nokey=1:noprint_wrappers=1 audio.m4a || echo "")
          if [ -z "$DUR" ] || [ "$DUR" = "N/A" ]; then
            DUR=$(ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 audio.m4a || echo "60")
          fi
          if [ -z "$DUR" ] || [ "$DUR" = "N/A" ]; then DUR="60"; fi
          echo "dur=$DUR" >> $GITHUB_OUTPUT
          echo "Audio duration (s): $DUR"
          printf "%s" "$DUR" > audio_dur.txt

      - name: Download videos (talking_head_then_broll mode)
        shell: bash
        run: |
          set -euo pipefail
          UA="Mozilla/5.0 (X11; Linux x86_64; GH-Actions)"

          if [ "$LAYOUT_TYPE" = "talking_head_then_broll" ]; then
            echo "=== Downloading TALKING HEAD ==="
            TH_URL=$(jq -r '.layout_config.talking_head_url' payload.json)
            echo "Downloading talking head: $TH_URL"
            curl -L --fail --retry 5 --retry-delay 2 -A "$UA" "$TH_URL" -o "talking_head.mp4" || {
              echo "ERROR: Failed to download talking head"
              exit 1
            }

            echo "=== Downloading BROLL videos ==="
            i=0
            jq -r '.layout_config.broll_videos[]' payload.json | while read -r URL; do
              i=$((i+1))
              [ $i -le $MAX_CLIPS ] || break
              echo "Downloading broll $i: $URL"
              curl -L --fail --retry 5 --retry-delay 2 -A "$UA" "$URL" -o "broll_${i}.mp4" || echo "WARN failed $URL"
            done
          else
            echo "=== Downloading videos (single mode) ==="
            i=0
            jq -r '[.video_urls] | flatten | unique[]' payload.json | while read -r URL; do
              i=$((i+1))
              [ $i -le $MAX_CLIPS ] || break
              echo "Downloading $i: $URL"
              curl -L --fail --retry 5 --retry-delay 2 -A "$UA" "$URL" -o "in_${i}.mp4" || echo "WARN failed $URL"
            done
          fi

          echo "Download complete"
          ls -lh *.mp4 2>/dev/null || true

      - name: Normalize talking head (9:16 portrait)
        shell: bash
        run: |
          set -euo pipefail
          
          if [ "$LAYOUT_TYPE" = "talking_head_then_broll" ] && [ -f "talking_head.mp4" ]; then
            echo "Normalizing talking head to ${WIDTH}x${HEIGHT}, speed=${TH_SPEED}"
            ffmpeg -y -i "talking_head.mp4" \
              -vf "scale=${WIDTH}:${HEIGHT}:force_original_aspect_ratio=increase,crop=${WIDTH}:${HEIGHT},setsar=1,fps=${FPS},setpts=PTS/${TH_SPEED}" \
              -an -c:v libx264 -preset veryfast -crf 18 -pix_fmt yuv420p -g $((FPS*2)) "norm_talking_head.mp4"
          fi

      - name: Normalize broll clips (9:16 portrait)
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob

          if [ "$LAYOUT_TYPE" = "talking_head_then_broll" ]; then
            for f in broll_*.mp4; do
              n=${f#broll_}; n=${n%.mp4}
              echo "Normalizing broll clip $n"
              ffmpeg -y -i "$f" \
                -vf "scale=${WIDTH}:${HEIGHT}:force_original_aspect_ratio=increase,crop=${WIDTH}:${HEIGHT},setsar=1,fps=${FPS}" \
                -an -c:v libx264 -preset veryfast -crf 18 -pix_fmt yuv420p -g $((FPS*2)) "norm_broll_${n}.mp4"
            done
          else
            for f in in_*.mp4; do
              n=${f#in_}; n=${n%.mp4}
              echo "Normalizing $f"
              ffmpeg -y -i "$f" \
                -vf "scale=${WIDTH}:${HEIGHT}:force_original_aspect_ratio=increase,crop=${WIDTH}:${HEIGHT},setsar=1,fps=${FPS}" \
                -an -c:v libx264 -preset veryfast -crf 18 -pix_fmt yuv420p -g $((FPS*2)) "norm_${n}.mp4"
            done
          fi

      - name: Create talking_head_then_broll sequence
        shell: bash
        run: |
          set -euo pipefail
          
          if [ "$LAYOUT_TYPE" != "talking_head_then_broll" ]; then
            exit 0
          fi

          AUDIO_DUR=$(cat audio_dur.txt)
          
          TH_DUR=$(ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 "norm_talking_head.mp4" || echo "0")
          
          if awk "BEGIN {exit !($TH_DUR > $AUDIO_DUR)}"; then
            TH_DUR=$AUDIO_DUR
          fi
          
          echo "Talking head: ${TH_DUR}s, Audio: ${AUDIO_DUR}s"
          
          ffmpeg -y -i "norm_talking_head.mp4" -t "$TH_DUR" \
            -c:v libx264 -preset veryfast -crf 18 -pix_fmt yuv420p -r "$FPS" \
            "seg_talking_head.mp4"
          
          REMAIN=$(awk -v a="$AUDIO_DUR" -v t="$TH_DUR" 'BEGIN {r=a-t; if(r<0)r=0; print r}')
          
          echo "Remaining time for broll: ${REMAIN}s"
          
          if awk "BEGIN {exit !($REMAIN > 0)}"; then
            CHUNKS=$(awk -v r="$REMAIN" -v c="$CHUNK_SEC" 'BEGIN {print int(r/c + 0.999999)}')
            if [ "$CHUNKS" -lt 1 ]; then CHUNKS=1; fi
            
            echo "Creating $CHUNKS broll chunks"
            
            shopt -s nullglob
            BFILES=(norm_broll_*.mp4)
            BCOUNT=${#BFILES[@]}
            
            if [ "$BCOUNT" -lt 1 ]; then
              echo "Error: No broll files found"
              exit 1
            fi
            
            rm -f concat_broll.txt
            for n in $(seq 1 "$CHUNKS"); do
              idx=$(( (n - 1) % BCOUNT ))
              src="${BFILES[$idx]}"
              
              ffmpeg -y -i "$src" -t "$CHUNK_SEC" \
                -c:v libx264 -preset veryfast -crf 18 -pix_fmt yuv420p -r "$FPS" \
                "broll_chunk_${n}.mp4"
              
              echo "file broll_chunk_${n}.mp4" >> concat_broll.txt
            done
            
            ffmpeg -y -f concat -safe 0 -i concat_broll.txt -c copy broll_seq_raw.mp4
            
            ffmpeg -y -i broll_seq_raw.mp4 -t "$REMAIN" \
              -c:v libx264 -preset veryfast -crf 18 -pix_fmt yuv420p -r "$FPS" \
              "seg_broll.mp4"
            
            cat > concat_all.txt <<'CONCAT_EOF'
          file seg_talking_head.mp4
          file seg_broll.mp4
          CONCAT_EOF
            
            ffmpeg -y -f concat -safe 0 -i concat_all.txt -c copy stack.mp4
          else
            cp seg_talking_head.mp4 stack.mp4
          fi

      - name: Build TikTok style ASS transcription
        shell: bash
        run: |
          set -euo pipefail

          if [ ! -s script.txt ]; then
            echo "No script.txt, skipping subtitles."
            touch subs.missing
            exit 0
          fi

          TOTAL_SEC=$(cat audio_dur.txt)
          TEXT=$(sed '/^[[:space:]]*$/d' script.txt | tr '\n' ' ' | sed 's/  */ /g')
          
          if [ -z "$TEXT" ]; then
            echo "script.txt has no content, skipping subtitles."
            touch subs.missing
            exit 0
          fi

          mapfile -t WORDS < <(echo "$TEXT" | tr ' ' '\n' | sed '/^[[:space:]]*$/d')
          
          if [ "${#WORDS[@]}" -eq 0 ]; then
            echo "No words found, skipping subtitles."
            touch subs.missing
            exit 0
          fi

          total_chars=0
          declare -a word_chars
          for i in "${!WORDS[@]}"; do
            c=${#WORDS[$i]}
            [ "$c" -lt 1 ] && c=1
            word_chars[$i]=$c
            total_chars=$(( total_chars + c ))
          done

          CAPTION_X=$((WIDTH / 2))
          CAPTION_Y=$((HEIGHT / 2))

          cat > subs.ass <<'ASS_HEADER'
          [Script Info]
          ScriptType: v4.00+
          PlayResX: 1080
          PlayResY: 1920
          WrapStyle: 2
          ScaledBorderAndShadow: yes

          [V4+ Styles]
          Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
          Style: Reels,DejaVu Sans Bold,54,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,1,0,0,0,100,100,0,0,1,6,2,5,60,60,20,1

          [Events]
          Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
          ASS_HEADER

          sed -i "s/PlayResX: 1080/PlayResX: ${WIDTH}/" subs.ass
          sed -i "s/PlayResY: 1920/PlayResY: ${HEIGHT}/" subs.ass

          start=0
          MIN_DURATION=0.28
          pad=0.06
          WORDS_PER_CHUNK=3

          i=0
          while [ $i -lt ${#WORDS[@]} ]; do
            chunk_end=$((i + WORDS_PER_CHUNK))
            if [ $chunk_end -gt ${#WORDS[@]} ]; then
              chunk_end=${#WORDS[@]}
            fi
            chunk_size=$((chunk_end - i))

            chunk_chars=0
            for ((j=i; j<chunk_end; j++)); do
              chunk_chars=$((chunk_chars + word_chars[j]))
            done

            chunk_duration=$(awk -v t="$TOTAL_SEC" -v c="$chunk_chars" -v sum="$total_chars" -v min="$MIN_DURATION" -v size="$chunk_size" 'BEGIN{
              d=t*(c/sum);
              if (d<(min*size)) d=min*size;
              print d;
            }')

            chunk_start_time=$start
            chunk_end_time=$(awk -v a="$start" -v d="$chunk_duration" 'BEGIN{print a+d}')

            if [ $chunk_end -ge ${#WORDS[@]} ]; then
              chunk_end_time=$(awk -v t="$TOTAL_SEC" -v p="$pad" 'BEGIN{e=t-p; if(e<0)e=0; print e}')
              ok=$(awk -v a="$start" -v e="$chunk_end_time" 'BEGIN{print (e>a)?1:0}')
              [ "$ok" -ne 1 ] && chunk_end_time=$(awk -v a="$start" 'BEGIN{print a+1.0}')
            fi

            full_text=""
            for ((k=i; k<chunk_end; k++)); do
              word="${WORDS[k]}"
              esc="${word//\\/\\\\}"
              esc="${esc//\{/\\{}"
              esc="${esc//\}/\\}}"
              full_text="${full_text}${esc}"
              if [ $k -lt $((chunk_end - 1)) ]; then
                full_text="${full_text} "
              fi
            done

            chunk_s_str=$(awk -v t="$chunk_start_time" 'BEGIN{
              if (t<0) t=0;
              h=int(t/3600); m=int((t-h*3600)/60); s=t-h*3600-m*60;
              cs=int((s - int(s))*100);
              printf("%d:%02d:%02d.%02d", h, m, int(s), cs);
            }')
            
            chunk_e_str=$(awk -v t="$chunk_end_time" 'BEGIN{
              if (t<0) t=0;
              h=int(t/3600); m=int((t-h*3600)/60); s=t-h*3600-m*60;
              cs=int((s - int(s))*100);
              printf("%d:%02d:%02d.%02d", h, m, int(s), cs);
            }')

            printf 'Dialogue: 0,%s,%s,Reels,,0,0,0,,{\\an5\\pos(%d,%d)\\blur0.4\\fad(80,80)}%s\n' \
              "$chunk_s_str" "$chunk_e_str" "$CAPTION_X" "$CAPTION_Y" "$full_text" >> subs.ass

            word_start=$start
            for ((j=i; j<chunk_end; j++)); do
              word_len=${word_chars[j]}

              word_duration=$(awk -v total="$chunk_duration" -v c="$word_len" -v sum="$chunk_chars" -v min="$MIN_DURATION" 'BEGIN{
                d=total*(c/sum);
                if (d<min) d=min;
                print d;
              }')

              word_end=$(awk -v a="$word_start" -v d="$word_duration" 'BEGIN{print a+d}')
              if [ $j -eq $((chunk_end - 1)) ]; then
                word_end=$chunk_end_time
              fi

              s_str=$(awk -v t="$word_start" 'BEGIN{
                if (t<0) t=0;
                h=int(t/3600); m=int((t-h*3600)/60); s=t-h*3600-m*60;
                cs=int((s - int(s))*100);
                printf("%d:%02d:%02d.%02d", h, m, int(s), cs);
              }')
              
              e_str=$(awk -v t="$word_end" 'BEGIN{
                if (t<0) t=0;
                h=int(t/3600); m=int((t-h*3600)/60); s=t-h*3600-m*60;
                cs=int((s - int(s))*100);
                printf("%d:%02d:%02d.%02d", h, m, int(s), cs);
              }')

              text=""
              for ((k=i; k<chunk_end; k++)); do
                word="${WORDS[k]}"
                esc="${word//\\/\\\\}"
                esc="${esc//\{/\\{}"
                esc="${esc//\}/\\}}"

                if [ $k -eq $j ]; then
                  text="${text}{\\c&H00FFFF&}${esc}{\\c&H00FFFFFF&}"
                else
                  text="${text}{\\alpha&HFF&}${esc}{\\alpha&H00&}"
                fi

                if [ $k -lt $((chunk_end - 1)) ]; then
                  text="${text} "
                fi
              done

              printf 'Dialogue: 1,%s,%s,Reels,,0,0,0,,{\\an5\\pos(%d,%d)\\blur0.4\\fad(80,80)}%s\n' \
                "$s_str" "$e_str" "$CAPTION_X" "$CAPTION_Y" "$text" >> subs.ass

              word_start=$word_end
            done

            i=$chunk_end
            start=$chunk_end_time
          done

      - name: Burn subtitles and mux audio
        shell: bash
        run: |
          set -euo pipefail

          FILTER_ARGS=()
          if [ -s subs.ass ]; then
            FILTER_ARGS=(-vf "subtitles=subs.ass")
          fi

          ffmpeg -y -stream_loop -1 -i stack.mp4 -i audio.m4a \
            "${FILTER_ARGS[@]}" \
            -map 0:v:0 -map 1:a:0 \
            -shortest \
            -c:v libx264 -profile:v high -pix_fmt yuv420p -r "$FPS" \
            -c:a copy \
            -movflags +faststart "$OUT_NAME"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: reel-output
          path: ${{ env.OUT_NAME }}
          retention-days: 90
