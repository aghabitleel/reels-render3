name: render

on:
  repository_dispatch:
    types: [render_reel]

permissions:
  contents: read

jobs:
  render:
    runs-on: ubuntu-latest
    timeout-minutes: 90

    env:
      # HARD CAP: final mp4 must be under 250 MB
      # 250,000,000 bytes = 250 MB (decimal). If you want MiB, use 262144000.
      MAX_OUTPUT_BYTES: 250000000

      # Keep music audio modest, then we blend with the source audio at low volume
      MUSIC_AUDIO_BITRATE_K: 96

      # Source (Pexels) background audio bitrate (we re-encode anyway)
      SRC_AUDIO_BITRATE_K: 64

      # Ratio: source background audio is quieter than music
      # music_gain=1.0 means unchanged, bg_gain=0.15 means very low background
      BG_GAIN: "0.15"
      MUSIC_GAIN: "1.00"

      # Safety margin so we do not accidentally exceed the cap
      SIZE_SAFETY: "0.88"

      # Max number of audio files to stitch
      MAX_AUDIO_FILES: "10"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install deps
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq ffmpeg curl

      - name: Write payload to file
        shell: bash
        run: |
          set -euo pipefail
          cat > payload.json <<'JSON'
          ${{ toJson(github.event.client_payload) }}
          JSON

      - name: Extract variables
        shell: bash
        run: |
          set -euo pipefail

          VIDEO_URL="$(jq -r '.layout_config.video_url // empty' payload.json)"
          OUT_NAME="$(jq -r '.out_name // "output.mp4"' payload.json)"
          WIDTH="$(jq -r '.width // 1920' payload.json)"
          HEIGHT="$(jq -r '.height // 1080' payload.json)"
          FPS="$(jq -r '.fps // 30' payload.json)"
          TARGET_MINUTES="$(jq -r '.target_minutes // 30' payload.json)"
          XFADE_SEC="$(jq -r '.xfade_sec // 0.35' payload.json)"

          if [ -z "$VIDEO_URL" ]; then
            echo "Missing layout_config.video_url in payload.json"
            cat payload.json
            exit 1
          fi

          echo "VIDEO_URL=$VIDEO_URL" >> "$GITHUB_ENV"
          echo "OUT_NAME=$OUT_NAME" >> "$GITHUB_ENV"
          echo "WIDTH=$WIDTH" >> "$GITHUB_ENV"
          echo "HEIGHT=$HEIGHT" >> "$GITHUB_ENV"
          echo "FPS=$FPS" >> "$GITHUB_ENV"
          echo "TARGET_MINUTES=$TARGET_MINUTES" >> "$GITHUB_ENV"
          echo "XFADE_SEC=$XFADE_SEC" >> "$GITHUB_ENV"

      - name: Download source video (Pexels)
        shell: bash
        run: |
          set -euo pipefail
          UA="Mozilla/5.0 (X11; Linux x86_64; GH-Actions)"
          curl -L --fail --retry 5 --retry-delay 2 -A "$UA" "$VIDEO_URL" -o source.mp4

      - name: Normalize source video (keep audio as separate optional track)
        shell: bash
        run: |
          set -euo pipefail

          # Normalize video to consistent resolution/fps, keep audio out for now
          ffmpeg -y -i source.mp4 \
            -vf "scale=${WIDTH}:${HEIGHT}:force_original_aspect_ratio=increase,crop=${WIDTH}:${HEIGHT},setsar=1,fps=${FPS}" \
            -an -c:v libx264 -preset veryfast -crf 23 -pix_fmt yuv420p -g $((FPS*2)) norm_video.mp4

          # Try extract source audio (may fail if no audio). Never fail the job.
          if ffprobe -v error -select_streams a:0 -show_entries stream=codec_name -of csv=p=0 source.mp4 >/dev/null 2>&1; then
            ffmpeg -y -i source.mp4 -vn -ac 2 -ar 48000 -c:a aac -b:a "${SRC_AUDIO_BITRATE_K}k" src_audio.m4a || true
          else
            echo "No audio stream detected in source.mp4"
          fi

      - name: Compute target bitrates for max file size
        shell: bash
        run: |
          set -euo pipefail

          TARGET_SEC=$(awk -v m="$TARGET_MINUTES" 'BEGIN{printf("%.0f", m*60)}')
          MAX_BYTES="${MAX_OUTPUT_BYTES}"
          SAFETY="${SIZE_SAFETY}"

          # Total bitrate budget for mp4 (kbps)
          TOTAL_K=$(awk -v b="$MAX_BYTES" -v s="$TARGET_SEC" -v f="$SAFETY" 'BEGIN{
            kbps = (b*8)/(s*1000)*f;
            if (kbps < 180) kbps = 180;
            printf("%.0f", kbps);
          }')

          MUSIC_K="${MUSIC_AUDIO_BITRATE_K}"
          # We will always output ONE final audio track (mixed), so reserve MUSIC_K for that.
          VIDEO_K=$(( TOTAL_K - MUSIC_K ))
          if [ "$VIDEO_K" -lt 120 ]; then
            VIDEO_K=120
          fi

          echo "TARGET_SEC=$TARGET_SEC" >> "$GITHUB_ENV"
          echo "TOTAL_BITRATE_K=$TOTAL_K" >> "$GITHUB_ENV"
          echo "VIDEO_BITRATE_K=$VIDEO_K" >> "$GITHUB_ENV"
          echo "FINAL_AUDIO_BITRATE_K=$MUSIC_K" >> "$GITHUB_ENV"

          echo "Target duration: ${TARGET_SEC}s"
          echo "Max bytes: ${MAX_BYTES}"
          echo "Total target bitrate: ${TOTAL_K} kbps"
          echo "Video bitrate: ${VIDEO_K} kbps"
          echo "Final audio bitrate: ${MUSIC_K} kbps"

      - name: Create looped video (size-capped)
        shell: bash
        run: |
          set -euo pipefail

          TARGET_SEC="${TARGET_SEC}"
          VIDEO_K="${VIDEO_BITRATE_K}"
          FPS="${FPS}"

          CLIP_DUR=$(ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 norm_video.mp4)

          XFADE=$(awk -v x="$XFADE_SEC" -v d="$CLIP_DUR" 'BEGIN{
            max=d*0.25;
            if (x<=0) x=0.20;
            if (x>max) x=max;
            printf("%.3f", x);
          }')

          N=$(awk -v target="$TARGET_SEC" -v d="$CLIP_DUR" -v x="$XFADE" 'BEGIN{
            denom=(d-x);
            if (denom<=0.1) denom=0.1;
            n=int((target + x)/denom + 0.999999);
            if (n<2) n=2;
            print n;
          }')

          INPUTS=()
          for i in $(seq 1 "$N"); do INPUTS+=(-i norm_video.mp4); done

          FILTER="[0:v]setpts=PTS-STARTPTS[v0];"
          for i in $(seq 1 $((N-1))); do FILTER+="[$i:v]setpts=PTS-STARTPTS[v$i];"; done

          OFFSET=$(awk -v d="$CLIP_DUR" -v x="$XFADE" 'BEGIN{printf("%.3f", d-x)}')
          FILTER+="[v0][v1]xfade=transition=fade:duration=${XFADE}:offset=${OFFSET}[x1];"

          if [ "$N" -gt 2 ]; then
            for i in $(seq 2 $((N-1))); do
              OFFSET=$(awk -v d="$CLIP_DUR" -v x="$XFADE" -v k="$((i-1))" 'BEGIN{
                off = k*d - k*x + (d-x);
                printf("%.3f", off);
              }')
              FILTER+="[x$((i-1))][v$i]xfade=transition=fade:duration=${XFADE}:offset=${OFFSET}[x$i];"
            done
          fi

          LAST="x$((N-1))"

          ffmpeg -y "${INPUTS[@]}" \
            -filter_complex "$FILTER" \
            -map "[$LAST]" \
            -t "$TARGET_SEC" \
            -c:v libx264 -preset veryfast \
            -b:v "${VIDEO_K}k" -maxrate "${VIDEO_K}k" -bufsize "$((VIDEO_K*2))k" \
            -pix_fmt yuv420p -r "$FPS" -g $((FPS*2)) \
            -movflags +faststart loop_video.mp4

      - name: Download and build looped music audio from audio_urls
        shell: bash
        run: |
          set -euo pipefail
          UA="Mozilla/5.0 (X11; Linux x86_64; GH-Actions)"
          TARGET_SEC="${TARGET_SEC}"
          MAX_N="${MAX_AUDIO_FILES}"

          jq -r 'try .audio_urls // [] | .[]' payload.json > audio_urls.txt || true

          if [ ! -s audio_urls.txt ]; then
            echo "No audio_urls provided, generating silence for music track"
            ffmpeg -y -f lavfi -i anullsrc=channel_layout=stereo:sample_rate=48000 \
              -t "$TARGET_SEC" -c:a pcm_s16le music.wav
            exit 0
          fi

          i=0
          while IFS= read -r url; do
            url="$(echo "$url" | tr -d '\r' | xargs || true)"
            [ -z "$url" ] && continue

            if [[ "$url" == //* ]]; then
              url="https:${url}"
            fi

            if [[ "$url" != https://* ]]; then
              echo "Skipping non-https url: $url"
              continue
            fi

            i=$((i+1))
            if [ "$i" -gt "$MAX_N" ]; then break; fi

            echo "Downloading music $i: $url"
            if ! curl -L --fail --retry 5 --retry-delay 2 -A "$UA" "$url" -o "m${i}.bin"; then
              echo "Failed to download $url, skipping"
              i=$((i-1))
              continue
            fi

            if ! ffmpeg -y -i "m${i}.bin" -vn -ac 2 -ar 48000 -c:a pcm_s16le "m${i}.wav"; then
              echo "ffmpeg failed for m${i}.bin, skipping"
              rm -f "m${i}.bin"
              i=$((i-1))
              continue
            fi
          done < audio_urls.txt

          COUNT=$(ls -1 m*.wav 2>/dev/null | wc -l | tr -d ' ')
          if [ "$COUNT" -lt 1 ]; then
            echo "No valid music downloaded, generating silence"
            ffmpeg -y -f lavfi -i anullsrc=channel_layout=stereo:sample_rate=48000 \
              -t "$TARGET_SEC" -c:a pcm_s16le music.wav
            exit 0
          fi

          if [ "$COUNT" -eq 1 ]; then
            ffmpeg -y -stream_loop -1 -i m1.wav -t "$TARGET_SEC" -c:a pcm_s16le music.wav
            exit 0
          fi

          INPUTS=()
          for n in $(seq 1 "$COUNT"); do INPUTS+=(-i "m${n}.wav"); done

          FILTER=""
          for n in $(seq 0 $((COUNT-1))); do
            FILTER+="[$n:a]aformat=sample_fmts=fltp:channel_layouts=stereo,aresample=48000[a$n];"
          done

          FILTER+="[a0][a1]acrossfade=d=1:c1=tri:c2=tri[m1];"
          if [ "$COUNT" -gt 2 ]; then
            for n in $(seq 2 $((COUNT-1))); do
              FILTER+="[m$((n-1))][a$n]acrossfade=d=1:c1=tri:c2=tri[m$n];"
            done
            LAST="m$((COUNT-1))"
          else
            LAST="m1"
          fi

          ffmpeg -y "${INPUTS[@]}" -filter_complex "$FILTER" -map "[$LAST]" playlist.wav
          ffmpeg -y -stream_loop -1 -i playlist.wav -t "$TARGET_SEC" -c:a pcm_s16le music.wav

      - name: Mix music with source background audio (if present)
        shell: bash
        run: |
          set -euo pipefail
          TARGET_SEC="${TARGET_SEC}"

          BG_GAIN="${BG_GAIN}"
          MUSIC_GAIN="${MUSIC_GAIN}"

          if [ -f src_audio.m4a ]; then
            echo "Source audio found, mixing with music. BG_GAIN=${BG_GAIN}, MUSIC_GAIN=${MUSIC_GAIN}"
            ffmpeg -y \
              -i music.wav \
              -i src_audio.m4a \
              -filter_complex "\
                [0:a]volume=${MUSIC_GAIN},aformat=sample_fmts=fltp:channel_layouts=stereo,aresample=48000[m]; \
                [1:a]volume=${BG_GAIN},aformat=sample_fmts=fltp:channel_layouts=stereo,aresample=48000,aloop=loop=-1:size=2e+09[bg]; \
                [m][bg]amix=inputs=2:duration=first:dropout_transition=2, \
                loudnorm=I=-16:TP=-1.5:LRA=11 \
                [out]" \
              -map "[out]" -t "$TARGET_SEC" -c:a aac -b:a "${MUSIC_AUDIO_BITRATE_K}k" mixed_audio.m4a
          else
            echo "No source audio, using music only"
            ffmpeg -y -i music.wav -t "$TARGET_SEC" -c:a aac -b:a "${MUSIC_AUDIO_BITRATE_K}k" mixed_audio.m4a
          fi

      - name: Mux video + mixed audio
        shell: bash
        run: |
          set -euo pipefail
          ffmpeg -y -i loop_video.mp4 -i mixed_audio.m4a \
            -map 0:v:0 -map 1:a:0 -shortest \
            -c:v copy -c:a aac -b:a "${MUSIC_AUDIO_BITRATE_K}k" \
            -movflags +faststart "${OUT_NAME}"

      - name: Enforce max size 250MB (adaptive re-encode, may reduce resolution)
        shell: bash
        run: |
          set -euo pipefail

          MAX_BYTES="${MAX_OUTPUT_BYTES}"
          OUT="${OUT_NAME}"
          TARGET_SEC="${TARGET_SEC}"

          bytes() { stat -c%s "$1"; }

          ACTUAL_BYTES=$(bytes "$OUT")
          echo "Output size: $ACTUAL_BYTES bytes, max $MAX_BYTES"

          if [ "$ACTUAL_BYTES" -le "$MAX_BYTES" ]; then
            echo "OK: under max size"
            exit 0
          fi

          echo "Too large. Applying stricter bitrate, then if needed drop resolution to 1280x720."

          # Try 1: lower video bitrate aggressively at same resolution
          SAFETY="0.80"
          AUDIO_K="${MUSIC_AUDIO_BITRATE_K}"

          TOTAL_K=$(awk -v b="$MAX_BYTES" -v s="$TARGET_SEC" -v f="$SAFETY" 'BEGIN{
            kbps = (b*8)/(s*1000)*f;
            if (kbps < 140) kbps = 140;
            printf("%.0f", kbps);
          }')
          VIDEO_K=$(( TOTAL_K - AUDIO_K ))
          if [ "$VIDEO_K" -lt 90 ]; then VIDEO_K=90; fi

          echo "Retry encode at same res, video ${VIDEO_K}k audio ${AUDIO_K}k"

          ffmpeg -y -i loop_video.mp4 -i mixed_audio.m4a \
            -map 0:v:0 -map 1:a:0 -shortest \
            -c:v libx264 -preset veryfast \
            -b:v "${VIDEO_K}k" -maxrate "${VIDEO_K}k" -bufsize "$((VIDEO_K*2))k" \
            -c:a aac -b:a "${AUDIO_K}k" \
            -movflags +faststart "${OUT}.tmp.mp4"

          mv "${OUT}.tmp.mp4" "${OUT}"
          ACTUAL_BYTES=$(bytes "$OUT")
          echo "After retry1 size: $ACTUAL_BYTES bytes"

          if [ "$ACTUAL_BYTES" -le "$MAX_BYTES" ]; then
            echo "OK after retry1"
            exit 0
          fi

          # Try 2: reduce resolution to 1280x720 and re-encode
          echo "Still too large. Downscaling to 1280x720."

          TOTAL_K=$(awk -v b="$MAX_BYTES" -v s="$TARGET_SEC" -v f="0.82" 'BEGIN{
            kbps = (b*8)/(s*1000)*f;
            if (kbps < 140) kbps = 140;
            printf("%.0f", kbps);
          }')
          VIDEO_K=$(( TOTAL_K - AUDIO_K ))
          if [ "$VIDEO_K" -lt 80 ]; then VIDEO_K=80; fi

          ffmpeg -y -i loop_video.mp4 -i mixed_audio.m4a \
            -map 0:v:0 -map 1:a:0 -shortest \
            -vf "scale=1280:720:force_original_aspect_ratio=increase,crop=1280:720,setsar=1" \
            -c:v libx264 -preset veryfast \
            -b:v "${VIDEO_K}k" -maxrate "${VIDEO_K}k" -bufsize "$((VIDEO_K*2))k" \
            -c:a aac -b:a "${AUDIO_K}k" \
            -movflags +faststart "${OUT}.tmp.mp4"

          mv "${OUT}.tmp.mp4" "${OUT}"
          ACTUAL_BYTES=$(bytes "$OUT")
          echo "After retry2 size: $ACTUAL_BYTES bytes"

          if [ "$ACTUAL_BYTES" -gt "$MAX_BYTES" ]; then
            echo "Still above 250MB. Reduce target_minutes or lower resolution further (e.g., 854x480)."
            exit 1
          fi

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: reel-output
          path: ${{ env.OUT_NAME }}
          retention-days: 14
